#!/usr/bin/env bash

# Globla declarations
declare -A program_parent_dir
declare -A pkg_alias


function test_package_init {
    # Determine script name
    me=$(basename $0)

    # Try to autodetect path by looking at path used to invoke this script
    local uniquefile=".test_package_uniquefile"

    if [ "${0:0:1}" == "/" ]; then
	# Absolute path given
	test_package_base_dir=$(dirname $(dirname $0))
    else
	# Relative path given
	local script_absolute_path="$(pwd)/${0:1}"
	test_package_base_dir=$(dirname $(dirname $script_absolute_path))
    fi

    # Check if correct directory is detected
    if [ -f "${test_package_base_dir}/${uniquefile}" ]; then
	    TEST_PACKAGE_BASE_DIR=${test_package_base_dir}
    fi

    # Make sure TEST_PACKAGE_BASE_DIR is defined and exported
    if [ -z "${TEST_PACKAGE_BASE_DIR}" ]; then
	echo "Error: Unable to autodetect path to the test package directory "
	exit 1
    fi
    export TEST_PACKAGE_BASE_DIR

    pkgdir=${test_package_base_dir}/pkgs

    pkg_alias[all]=""

    for i in $(ls -d ${pkgdir}/*/); do
	local pkg_name=$(basename $i)
	pkg_alias["$pkg_name"]=""

	if [ "$(ls -A $i)" ]; then
	    for j in $(ls -d ${i}*/); do
		local program_name=$(basename $j)
		pkg_alias["$pkg_name"]="${pkg_alias[${pkg_name}]} $program_name"

		program_parent_dir["$program_name"]="$pkg_name"
	    done
	    pkg_alias["$pkg_name"]="${pkg_alias[${pkg_name}]:1}"

	    if [ -z "${pkg_alias[all]}" ]; then
		pkg_alias[all]="${pkg_alias[${pkg_name}]}"
	    else
		pkg_alias[all]="${pkg_alias[all]} ${pkg_alias[${pkg_name}]}"
	    fi
	fi
    done

}

function check_program_alias_valid {
    program_names=""

    local prog_names=$(echo $1 | sed 's/,/ /g')

    for program_name in $prog_names; do
	if ! [[ ${pkg_alias[all]} =~ (^| )$program_name($| ) ||
		    ${!pkg_alias[@]} =~ (^| )$program_name($| ) ]]; then
	    echo "Error: Wrong package name \"$program_name\""
	    exit 1
	fi

	if [[ ${!pkg_alias[@]} =~ (^| )$program_name($| ) ]]; then
	    program_names="$program_names ${pkg_alias[$program_name]}"
	else
	    program_names="$program_names $program_name"
	fi
    done

    # remove duplicates from program list
    program_names=$(echo "$program_names" | xargs -n1 | awk ' !x[$0]++' | xargs)
}

function show_available_programs {
    echo "Programs for given package input:"
    for program in ${program_names}; do
	echo "  $program"
    done

    echo
    echo "Aliases available in the package:"
    for program_alias in ${!pkg_alias[@]}; do
	echo "  $program_alias"
    done

}

function show_program_details {
    for program_name in $program_names; do

	if [[ ${!pkg_alias[@]} =~ (^| )$program_name($| ) ]]; then
	    echo "Cannot show details for a package. Enter a program name"
	fi

	local program_dir=${pkgdir}/${program_parent_dir[$program_name]}/$program_name
	local program_conf_dir=$program_dir/conf
	local inputs=""

	echo "==================================================="
	echo "Details for Program \"$program_name\""
	echo

	echo "Input types supported:"
	for i in $(ls ${program_conf_dir}/*.buildconf); do
	    local input_name=$(basename $i | sed 's/.buildconf//')
	    inputs="$inputs $input_name"
	    echo "  $input_name"
	done

	source ${program_conf_dir}/program.conf
	echo
	echo "Program versions available:"
	for i in ${program_types}; do
	    echo "  $i"
	done

	echo
    done

}

function process_args {

    # Usage
    usage="\
Usage $me -p PACKAGE [OPTIONS]...

Manage the perf data collection using test programs

Options:
  -p PACKAGE	- A list of packages or aliases on which the action is to
		  be performed.

  -l		- list all available programs

  -d		- show information for a given program or alias

  -t TYPE	- A list of program types (good, badfs, badma)

  -n THREADS	- A list of thread numbers to be run with programs

  -a ACTION	- Data collections type

  -o OUTPUT	- Name of the output file

  --perf-binary PERF_LOCATION - location of perf

  -h		- Displays this help message.

Actions:
  default	- Normal perf data collection
  functional	- use function wise perf data collection

Examples:
  $me -p all -n 1,2,4,8

  $me -p falseshare -n 1,2,4,8 -a functional

  $me -p swap -d

  $me -p swap -n 2,4 -t good,badfs"

# Default values used
program_names="${pkg_alias[all]}"
package_name="all"
thread_list="1"

show_help=""
show_list=""
show_details=""

while [[ ! -z "$1" ]]; do
    arg="$1"
    case "$arg" in
	"-h" )
	    show_help=true
	    ;;
	"-l" )
	    show_list=true
	    ;;
	"-d" )
	    show_details=true
	    ;;
	"-p" )
	    shift; arg="$1"
	    if [[ -z "$arg" ]] || [[ "$arg" =~ ^- ]]; then
		echo "$usage"
		exit 1
	    fi

	    check_program_alias_valid $arg
	    ;;
	* )
	    echo "$usage"
	    exit 1
	    ;;
    esac

    shift
done

}

function run_package {
    if [ $show_help ]; then
	echo "$usage"
	exit 1
    fi

    if [ $show_list ]; then
	show_available_programs
	exit 1
    fi

    if [ $show_details ]; then
	show_program_details
	exit 1
    fi
}

# Check Bash Version
if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
  # We use certain Bash 4 features.
  echo "Warning: At least bash version 4 is recommended. Current version is $BASH_VERSION."
fi

test_package_init

process_args $@

run_package
